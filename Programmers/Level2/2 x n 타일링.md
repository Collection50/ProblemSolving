# Programmers/2 x n 타일링

#DP

## Want

가로 길이가 `2`이고 세로의 길이가 `1`인 직사각형모양의 타일이 존재한다  
이 직사각형 타일을 이용하여 세로의 길이가 `2`이고 가로의 길이가 `n`인 바닥을 가득 채우려고 한다  
직사각형의 가로의 길이 `n`이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 반환하라

## INPUT && OUTPUT

```js
/**
 * @param {number} n
 * @return {number}
 */
```

## Solving Strategies

`DP`를 활용한 문제

[멀리뛰기 문제](https://school.programmers.co.kr/learn/courses/30/lessons/12914)와 똑같은 로직을 사용하고 있다  
차이점이라고 한다면 `n`이 `60,000` 이하이므로  
순진한 방법을 사용할 경우 시간 초과가 날 수밖에 없다  
또한 엄청 큰 값이 생성되므로 `1,000,000,007`으로 나눠주어야 한다

### solve 1

`DP`를 활용하여 해결  
문제의 핵심 키포인트는 각 덧셈 연산마다  
`1,000,000,007`로 나눈 나머지를 저장해야 한다는 점이다  
큰 수가 만들어지면 `1,000,000,007`로 나눌 수 없을 뿐더러  
결과적으로 동일한 값을 얻을 수 있기 때문이다

### solve 1 Code

```js
function solution(n) {
  const memo = [0, 1, 2];

  for (let i = 3; i <= n; i++) {
    memo.push((memo[i - 1] + memo[i - 2]) % 1_000_000_007);
  }

  return memo[n] % 1_000_000_007;
}
```

## 배운 점 or 주의할 점

처음엔 모든 경우의 수의 타일 수를 구하는 줄 알았는데  
문제를 천천히 이해하면서 생각보다 쉬운 문제로 귀결되었다

멀리뛰기 문제보다 정답률이 낮은 이유는  
덧셈 연산을 매번 `1,000,000,007`으로 나누는 이유도 있을테지만  
마지막 `return`문에서 `1,000,000,007`로 나누지 않으면 시간 초과가 난다;;  
이미 `memo[n]`에 저장된 값은 `1,000,000,007`로 나눠진 값인데 말이다

다른 언어로 테스트해보니(`C++`)  
동일 로직에 대하여 쉽게 통과하는 모습을 볼 수 있다  
`JS` 차별 ㄷㄷ
