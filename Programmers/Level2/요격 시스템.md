# Programmers/요격 시스템

#정렬

## Want

각 폭격 미사일의 x 좌표 범위 목록 `targets`이 매개변수로 주어진다  
모든 폭격 미사일을 요격하기 위해 필요한 요격 미사일 수의 최솟값을 반환하라  
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/181188)

## INPUT && OUTPUT

```js
/**
 * @param {number[][]} targets
 * @return {number}
 */
```

## Solving Strategies

1. 모든 공격에 대해 1발씩 발사해야 한다
2. 최소 공격으로 방어해야 한다

언제 발사할 것인가?  
선이 끝나기 전에는 발사해야 한다  
현재 선보다 짧은 선이 중간에 있는 경우엔?  
`end` 기준으로 오름차순으로 가는 것인가?  
아하아하!

### solve 1

1. 공격이 끝나는 지점을 기준으로 오름차순 정렬
2. 마지막 발사 위치 <= 현재 공격 시작점 => 발사 및 발사 위치 갱신
3. 마지막 발사 위치 > 현재 공격 시작점 => 쏘지 않아도 됨 (나중에 발사하는 걸로 같이 요격 가능)

결국 문제 해결의 핵심 전략은  
**공격이 끝나는 지점을 기준으로 오름차순 정렬**을 수행하는 것

### solve 1 Code

```js
const compare = (a, b) => a[1] - b[1];

function solution(targets) {
  let attackPoint = 0;
  return targets
    .slice()
    .sort(compare)
    .reduce((count, [start, end]) => {
      if (attackPoint <= start) {
        attackPoint = end;
        return count + 1;
      }
      return count;
    }, 0);
}
```

## 배운 점 or 주의할 점

얼핏보면 제한 사항인 `100,000,000`을 순회해야 한다고 생각할 수 있다  
하지만 `targets`를 순회하므로 시간 초과가 발생하지 않고 해결할 수 있다

결론적으로는 **공격이 끝나는 지점을 기준으로 정렬**하는 아이디어가 중요하다  
이를 도출해내는 것은 결국 모든 공격에 대해 1번씩 발사해야 한다는 점이다  
자연스럽게 **언제 발사해야 하는지에 대해 고민**하게 된다

공격의 시작 지점이 아닌 끝나는 지점으로 정렬하는 이유는 아래와 같다

공격이 끝나는 지점을 기준으로 정렬하면  
현재 공격이 끝나는 지점 > 직전 공격의 끝나는 지점을 만족한다

따라서 **현재 공격의 끝나는 지점에서 발사**했을 때  
미리 공격이 끝나 함께 발사하지 못하는 공격을 예방할 수 있다(공격 누락)  
따라서 발사 위치와 시작 지점을 비교하여 `count`를 갱신한다
